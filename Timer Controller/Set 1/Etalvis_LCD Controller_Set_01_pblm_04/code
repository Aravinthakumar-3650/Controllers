void init_port();
void init_timer();
void init_timer2();

volatile unsigned char mode = 0; 

void setup() 
{
  volatile long i;
  int j=0;
  init_port();
  init_timer();
  init_timer2();
  Serial.begin(9600);
  while(1)
  {
    for(i=0;i<450000;i++);
    Serial.println(j,DEC);
    j++;
  }
}

void init_timer()
{
  volatile char *Timer1_TCCR1A = 0X80;
  volatile char *Timer1_TCCR1B = 0X81;
  volatile short *Timer1_TCNT1 = 0X84; 
  volatile short *Timer1_OCR1A = 0X88;
  volatile char *Timer1_TIMSK1 = 0X6F;

  *Timer1_TCCR1A = 0;
  *Timer1_TCCR1B = 0;
  *Timer1_TCNT1 = 0;

  *Timer1_OCR1A = 31250;   
  *Timer1_TCCR1B = 0x0C;    
  *Timer1_TIMSK1 = 0X02;
}

void init_timer2()
{
  volatile char *Timer2_TCCR2A = 0xB0;
  volatile char *Timer2_TCCR2B = 0xB1;
  volatile char *Timer2_TCNT2  = 0xB2;
  volatile char *Timer2_OCR2A  = 0xB3;
  volatile char *Timer2_TIMSK2 = 0x70;

  *Timer2_TCCR2A = 0x02;    
  *Timer2_TCCR2B = 0x07;   
  *Timer2_TCNT2  = 0;
  *Timer2_OCR2A  = 156;   
  *Timer2_TIMSK2 = 0x02;
}

void init_port()
{
  volatile char *dira = (volatile char *)0x21;   
  *dira = 0x03;   
}

ISR(TIMER1_COMPA_vect)
{
  static unsigned char count1 = 0;
  volatile char *outa = (volatile char *)0x22;

  count1++;

  if(mode == 0)  
  {
    if(count1 >= 2) 
    {
      *outa ^= 0x01;
      count1 = 0;
    }
  }
  else          
  {
    if(count1 >= 4)
    {
      *outa ^= 0x01;
      count1 = 0;
    }
  }
}

ISR(TIMER2_COMPA_vect)
{
  static unsigned char count2 = 0;
  static unsigned char lastSwitch = 1;
  volatile char *outa = (volatile char *)0x22;
  volatile char *pina = (volatile char *)0x20;   

  if(((*pina & 0x04) == 0) && lastSwitch == 1)
  {
    mode ^= 1;  
    lastSwitch = 0;
  }
  if((*pina & 0x04) != 0) lastSwitch = 1;

  count2++;

  if(mode == 0)   
  {
    if(count2 >= 200)   
    {
      *outa ^= 0x02;
      count2 = 0;
    }
  }
  else            
  {
    if(count2 >= 100)
    {
      *outa ^= 0x02;
      count2 = 0;
    }
  }
}

void loop() {}
